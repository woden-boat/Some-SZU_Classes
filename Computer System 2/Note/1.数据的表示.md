# 数据的表示

## 0.在不同机器上数据的储存

### 0.1 不同数据类型占用的空间

|         | 32bits | 64bits |
| ------- | ------ | ------ |
| int     | 4字节  | 4字节  |
| long    | 4字节  | 8字节  |
| float   | 4字节  | 4字节  |
| double  | 8字节  | 8字节  |
| char    | 1字节  | 1字节  |
| pointer | 4字节  | 8字节  |

### 0.2 大端序 & 小端序

在数据需要由多个字节储存时，按照储存顺序分类有两种储存方法

* 小端序：先储存低字节数据
* 大端序：先储存高字节数据



## 1.整数

### 1.1 unsigned

$B2U(X) = \sum_{i = 0}^{w - 1}x_i \cdot 2^i$

可以表示的范围是$[0,2^w - 1]$

### 1.2 two's complement numbers（补码）

$B2T(X) = -x_{w - 1} \cdot 2^{w - 1} + \sum_{i = 0}^{w - 2} x_i \cdot 2^i$

即最高位用于表示符号，为1时是负数，0时是正数

可以表示的范围是$[-2^{w - 1},2^{w - 1} - 1]$ ，可以认为在这种表示法中0被归为“正数”

 ### 1.3 计算

* unsigned

​	将两个无符号整数相加，如果溢出则放弃多出来的bits位，以下是公式化的描述

$s = UADD_w(x,y) = (x + y) \, mod \, 2^{w}$ ，也就是说，unsigned的所有运算实质上都是模运算

* two's complement numbers

​	在有符号整数的运算之中，可能出现下溢出（两个太小的负数相加然后截断后变成正数）和上溢出（两个太大的正数相加并截断后变成负数）

```cpp
int s,t,u,v;
s = (int)((unsigned)u + (unsigned)v);
t = u + v;
/* s == t 为True */ 
```

* 乘法
    * 在底层上乘法由加法实现
    * 乘以$2^w$
        * 将二进制表示左移一位
    * 除以$2^w$
        * 将二进制表示右移一位
            * 对于无符号数来说空缺的位直接补0
            * 对于有符号数来说空缺的位补原来符号位的数

## 2.浮点数

浮点数存在表示局限，只能准确表示由$2^w$组合出来的数，其他数需要循环重复位才能准确表示，在计算机中这些数只能近似表示

### 2.1 IEEE浮点数表示法：核心是将浮点数表示为 $1.xxxxx \times 2^{Exp}$这样的形式

$$
x = (-1)^s \cdot M \cdot2^E
$$

### 2.2 储存

float: sign（1-bit）+ exp（8-bits）+ frac（23-bits）

double：sign（1-bit）+ exp（11-bits）+ frac（52-bits）

### 2.2 规格数 & 非规格数

（1）规格数

* exp不能为全0 or 全1
* $E = Exp - Bias$：偏置是将无符号数转化为有符号数
    * 使用偏置来表示有符号数的原因是可以直接逐位比较大小，而不需要再在阶码区判断一次符号位
    * $Exp$：可以看作一个k位无符号整数
    * $Bias = 2^{k - 1} - 1$：
        * 在float中是127
        * 在double中是1023
* $M = 1.xxxxxxx$：隐式的省略了小数点前的1，这样就多了一位出来以表示更大范围的浮点数
* 由于尾数有隐式1，所以规格数无法表示0

（2）非规格数

* exp为全0
* frac没有隐含的1，M和frac完全等价
* $E = 1 - Bias$
    * $E = 1 - Bias$ 而不是$E = -Bias$的原因：
        * 规格数能表示的最小正数是$2^{-126}$，非规格数能表示的最大正数是$(1 - \epsilon) \cdot 2^{-126}$，这两个数非常接近，以此实现规格数的最小值向0的平滑过渡
* 当exp和frac均为全0时，该浮点数表示0
    * 由于存在符号位，浮点数中有+0 和 -0

（3）特殊值

* exp为全1，frac为全0表示无穷大
* exp为全1，frac不为全0表示NaN

### 2.3 运算

（1）舍入：四舍六入五取最近的偶数

（2）加法：

* 提取符号位S，指数位（E）和尾数位（M，为实际数值，前导1或前导0会被显式的展示出来） 
* 找到较大的指数，将较小指数的浮点数的尾数右移，直到两个数的指数相同
* 尾数相加（符号位不同则尾数相减）
* 尾数相加后可能最高位不再为1

    * 最高位为0则需要左移尾数，并且指数减小
    * 相加后产生进位则出现了溢出，需要右移尾数，并且指数增加
* 注意：浮点数的加法只满足交换律，不满足结合律
    * 原因是浮点数的加法本质上是$x + y = round(x + y)$，舍入可能会使某些信息丢失

（3）乘法

* 符号位取异或
* 指数位相加（溢出则右移尾数）
* 尾数位相乘（进行舍入）









